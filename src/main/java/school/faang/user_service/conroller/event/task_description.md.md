# Организация события

## Описание

Как пользователь, я хочу иметь возможность организовать событие, чтобы привлечь людей на решение задачи.
Событие здесь - это любая активность, которую может провести человек на своей странице. 
Типа, вебинар, какой-нибудь опрос, розыгрыш и тд.

Необходимо реализовать основные операции: 
* создать событие, 
* получить событие, 
* получить все события с фильтрами,
* удалить событие, 
* обновить событие, 
* получить все созданные пользователем события 
* и получить все события, в которых участвует пользователь.

Ниже условия для реализации каждой операции. Делаем их поочередно. Можно делать их разными коммитами и отправлять 
на ревью каждую операцию отдельно, а можно все сразу.

### Создать событие
Реализовать возможность создавать(проводить) событие.

1. В пакете `dto.event` cоздайте класс `EventDto`, если его нет. Поля: 
   * `Long id`, 
   * `String title`, 
   * `LocalDateTime startDate`, 
   * `LocalDateTime endDate`, 
   * `Long ownerId`, 
   * `String description`, 
   * `List<SkillDto> relatedSkills`, 
   * `String locatio`n, 
   * `int maxAttendees`.

2. В пакете `controller.event` cоздайте класс `EventController`. Он будет отвечать за обработку запросов 
пользователя и валидацию этих запросов. Сделайте так, чтобы он был **_Spring bean_**. Внедрите в него бин класса `EventService` 
- его создадим в следующем пункте.

3. В классе `EventController` создайте метод `create(EventDto event)` , который возвращает `EventDto`.
   * В `create` нужно проверить, что полученный объект `event` валиден. 
   * Чтобы провалидировать переданные в метод данные, напишите свой метод валидации и реализуйте его. 
   * Ожидается, что 
     * `event` должен обязательно иметь название, и оно не должно быть пустым. 
     * Также событие должно иметь дату начала и пользователя, который проводит событие.  
   * Если валидация не прошла - выбросите исключение с описанием (про исключение читайте ниже). 
   * После валидации вызывать нужный метод класса `EventService`. См. ниже.

4. В пакете `service.event` cоздайте класс `EventService`. Он будет содержать бизнес-логику. Сделайте его _Spring bean_. 
Внедрите в него бин класса `EventRepository`. Этот класс уже предоставлен, можете использовать его методы.

5. Создайте в классе `EventService` метод `create(EventDto event)` с возвращаемым значением `EventDto` который будет 
вызываться из метода `create()` класса `EventController` для непосредственного выполнения нужного действия,
после того, как запрос пользователя отвалидирован. 
   * Здесь нужно проверить, что пользователь, который создает событие, имеет навыки, связанные с событием. 
   * Если у пользователя нет этих навыков, нужно вывести ошибку о том, что пользователь не может провести такое событие 
   с такими навыками. 
   * Если все в порядке, то нужно вызвать метода `save` класса `EventRepository`, который сохранит новое событие в базу данных.
   * Этот метод вернет объект `Event` - сущность, хранящуюся в базе данных. Вам нужно преобразовать ее в объект `EventDto`, 
   используя `Mapstruct` и вернуть объект `EventDto` в метод контроллера. 
   * Т.о. нужно создать новый маппер, если его нет, и заинжектить в `EventService`.

6. В пакете `exception` для всех исключений в этой задаче создайте свой класс `DataValidationException`, если его еще нет. 
Он должен наследоваться от `RuntimeException` и вызывать конструктор супер-класса, передавая в него полученное сообщение.

7. Весь написанный код покройте Unit-тестами.

### Получить событие
Реализовать возможность получить информацию о событии по его идентификатору.

1. В классе `EventController` создайте метод `getEvent`. Этот метод будет обрабатывать запрос и предоставлять запрошенное событие. 
Метод принимает id события.
   * Внутри метода нужно вызвать метод `getEvent(long eventId)` класса `EventService`.

2. Создайте в классе `EventService` метод `getEvent(long eventId)` для получения события.
    * Для получения события используйте метод `findById(long eventId)` из `EventRepository`. 
    * Если такое событие не было найдено, нужно выбросить исключение об этом.

3. Используйте `MapStruct`, чтобы преобразовать `Event` в `EventDto`, который метод должен вернуть.

4. Весь написанный код покройте **Unit**-тестами.

## Получить все события с фильтрами
Реализовать возможность получать список всех событий по определенному фильтру.

1. В классе `EventController` создайте метод `getEventsByFilter(EventFilterDto filter)`. 
   * Этот метод будет обрабатывать запрос и возвращать список всех рекомендаций по выбранному фильтру.
   * Внутри метода нужно вызвать метод `getEventsByFilter(filter)` класса `EventService`.

2. Создать класс `EventFilterDto`, который будет содержать поля, по которым можно фильтровать.

3. В методе `getEventsByFilter(EventFilterDto filter)` класса `EventService` нужно получить все события из базы, 
используя метод `findAll` класса `EventRepository`, а затем написать фильтр для полученных запросов.

4. Используйте `MapStruct` для преобразований.

5. Весь написанный код покройте **Unit**-тестами.

### Удалить событие
Реализовать возможность удалить событие.

1. В классе `EventController` создайте метод `deleteEvent`. 
   * Этот метод будет обрабатывать запрос: получать `id` события, которое должно быть удалено. 
   * Внутри метода нужно вызвать метод `deleteEvent(long eventId)` класса `EventService`.

2. Создайте в классе `EventService` метод `deleteEvent(long eventId)` для удаления события.

3. Покройте код unit-тестами

### Обновить событие
Реализовать возможность обновить событие, созданное пользователем. 
* Пользователь может обновить событие, автором которого он является. 
* Если автор добавляет какие-то навыки, которые развиваются на событии, то нужно проверить,
что сам автор такими навыками обладает. Иначе такие навыки добавить нельзя.
(человек не может рассказать о том, чего не знает сам)

1. В классе `EventController` создайте метод `updateEvent(EventDto event)`. 
   * Этот метод будет обрабатывать запрос и предоставлять количество подписчиков.

2. Проверить, что событие содержит название, дату начала и автора. 
   * Если событие прошло валидацию, вызовите метод `updateEvent(EventDto event)` класса `EventService`. 
   * Если событие не прошло валидацию, то нужно выбросить `DataValidationException`.

3. Создайте в классе `EventService` метод `updateEvent(EventDto event)` для обновления события. 
   * Здесь нужно проверить, что пользователь, который создает событие, имеет навыки, связанные с событием. 
   * Если у пользователя нет этих навыков, нужно вывести ошибку о том, что пользователь не может провести такое 
   событие с такими навыками. 
   * Если все в порядке, то нужно вызвать метода `save` класса `EventRepository`, который сохранит новое событие 
   в базу данных.
   * Этот метод вернет объект `Event` - сущность, хранящуюся в базе данных. Вам нужно преобразовать ее в объект `EventDto`.
  
4. Весь написанный код покройте Unit-тестами.

### Получить все созданные пользователем события
Реализовать возможность пользователю получить все созданные им события. 
Здесь нет валидаций, просто метод для получения.

1. В классе `EventController` создайте метод `getOwnedEvents`. 
   * Этот метод будет обрабатывать запрос и предоставлять список событий. 
   * Внутри метода нужно вызвать метод `getOwnedEvents(long userId)` класса `EventService`.

2. Создайте в классе `EventService` метод `getOwnedEvents(long userId)` для получения рекомендаций, 
используйте метод `findAllByUserId(long userId)` из `EventRepository`.

3. Весь написанный код покройте Unit-тестами.

### Получить все события, в которых пользователь принимает участие
Реализовать возможность пользователю получить все события, на которые он зарегистрировался. 
Здесь нет валидаций, просто метод для получения.

1. В классе `EventController` создайте метод `getParticipatedEvents`. 
   * Этот метод будет обрабатывать запрос и предоставлять список событий. 
   * Внутри метода нужно вызвать метод `getParticipatedEvents(long userId)` класса `EventService`.

2. Создайте в классе `EventService` метод `getParticipatedEvents(long userId)` для получения событий, 
используйте метод `findParticipatedEventsByUserId(long userId)` из `EventRepository`.

3. Весь написанный код покройте Unit-тестами.